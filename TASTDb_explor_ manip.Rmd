---
title: "Exploration et manipulation du tableau de données *Voyages*"
author: "Wilfrid Cariou"
date: "20 décembre 2015"
output: 
  html_document: 
    number_sections: yes
    toc: yes
---

# Préalables

## Importation des données

```{r}

voyages<-read.table("tastdb_105var.csv",
                    header=TRUE, sep=",",
                    na.strings="",
                    quote = "\"",
                    dec=".") 
```



## Références

* http://blog.datacamp.com/15-easy-solutions-data-frame-problems-r/  
* https://www.datacamp.com/courses/dplyr-data-manipulation-r-tutorial  
* http://personal.colby.edu/personal/m/mgimond/RIntro/04_Manipulating_data_tables.html#data-table-description  
* http://www.r-bloggers.com/imputing-missing-data-with-r-mice-package/  
* https://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html  
* https://stat545-ubc.github.io/block010_dplyr-end-single-table.html  


# Composition du tableau de données *voyages*

Un tableau de données ou *data.frame* constitue une structure de données fondamentale de **R**. Il se compose d'une collection d'objets de différents types (*numeric, factor, character*) de longueurs similaires accessibles par leur indice de position (R: A Language and Environment for Statistical Computing - Reference index, p 159).

## Dimensions du tableau

Un tableau de données est un tableau à deux dimensions. La fonction *dim(){base}*  permet d'en connaître le nombre de lignes et de colonnes (Becker, Chambers, Wilks, 1988).

```{r eval = FALSE}

dim (voyages)

```

## Désignation et indice de position des colonnes

* La fonction *colnames(){base}* est utilisée pour obtenir un affichage séquentiel des noms de colonnes. Chaque colonne est caractérisée par un *indice* de position au sein du tableau. l'indice du premier élément de chaque ligne est signalé dans la marge gauche de la console.   
* La fonction *wich(){base}* est une fonction primitive de **R** qui permet d'identifier l'indice de position d'un vecteur (d'une colonne) en fonction de son nom (Desgraupes, 2013, p10).  
* RStudio affiche également de manière interactive la position de chaque colonne du tableau de données.  

```{r eval = FALSE}

colnames (voyages)

````

  [1] "voyageid"    "shipname"    "natinimp"    "placcons"    "yrcons"      "placreg"     "yrreg"       "rig"        
  [9] "tonnage"     "tonmod"      "guns"        "ownera"      "ownerb"      "ownerc"      "ownerd"      "ownere"     
 [17] "ownerf"      "ownerg"      "ownerh"      "owneri"      "ownerj"      "ownerk"      "ownerl"      "ownerm"     
 [25] "ownern"      "ownero"      "ownerp"      "fate"        "fate2"       "fate3"       "fate4"       "resistance"

* La colonne *guns* se situe à la 11e position du tableau de données *voyages*.

```{r eval = FALSE}

which(colnames(voyages)=="slaximp")

```

* La colonne *slaximp* se situe à la 73e position du tableau de données *voyages*.


## Typage des données

```{r eval = FALSE}

str(voyages)

```


 $ voyageid   : **int**  1 2 3 4 5 6 7 8 9 10 ...  
 $ shipname   : **Factor** w/ 9105 levels "'s-Graveland",..: 6303 8461 6274 893 774 8837 2674 8771 1591 1485 ...  
 $ natinimp   : Factor w/ 8 levels "Denmark / Baltic",..: 6 6 6 6 6 6 6 6 6 6 ...  
 $ placcons   : Factor w/ 238 levels "Airth","Amesbury",..: NA NA NA NA NA NA NA NA NA NA ...  

* *voyageid*: objet de type **integer**  
* *shipname*: objet de type **Factor**  



### Les facteurs 

Un  *facteur (factor)* constitue un objet particulier de **R** employé pour stocker les modalités d'un caractère qualitatif.   
Un caractère est dit *qualitatif* lorsque son observation ne peut être traduite par une mesure. Il se décline selon différents états dénombrables appelés *modalités*. Dans **R**, les  *levels* correspondent aux modalités d'un caractère.  
L'inspection des modalités d'un caractère qualitatif s'effectue à l'aide de la fonction *levels() ou unique() {base}*. 

````{r eval=FALSE}

ports de départ des expéditions de traite 
levels (voyages$ptdepimp) # classement des modalités par ordre alphabétique
unique (voyages$ptdepimp) # absence de classement

# classement par ordre alphabétique (combinaison avec la fonction sort)
sort (unique (voyages$ptdepimp))

````

### Les vecteurs numériques 

Les vecteurs numériques *Integer* ou *numeric* sont des objets utilisés pour stocker les valeurs d'une variable quantitative. 

```{r eval = FALSE}

# Les premières valeurs  de la variable yearam
head(sort(unique(voyages$yearam)))

```

### Les Valeurs manquantes

#### Désignation

Dans **R**, les valeurs manquantes sont notées *NA* (not available).

#### Remarque

Par défaut, la plupart des fonctions de base (somme, moyenne, minimum, maximum, etc.) n'acceptent pas les variables 
contenant des valeurs manquantes.

#### Identification des valeurs manquantes

Références: http://www.statmethods.net/input/missingdata.html


La fonction *summary* permet entre autre d'indiquer les effectifs des valeurs manquantes pour chaque variable du tableau de données.

````{r eval=FALSE}

summary (voyages)

````

Effectifs et fréquences des valeurs manquantes *variable par variable*.

```{r eval = FALSE}

# fonction colSums à la constante logique is.na; 
# stockage des données manquantes dans l'objet missing_n

missing_n<-colSums(is.na(voyages))

missing_n # affichage dans la console

````

   voyageid    shipname    natinimp    placcons      yrcons     placreg       yrreg  
          0        1594        1529       26058       28757       27718       30431      
          
* Le vecteur  *voyageid*: ne contient pas de données manquantes.  
* *shipname*: contient 1594 données manquantes. 


```{r eval = FALSE}

# fonction colMeans associée à la constante logique is.na; 
# résultats exprimés en pourcentages, arrondis au dixième:
# stockage des données manquantes dans l'objet missing_freq.

missing_freq<-round (100*colMeans(is.na(voyages)), 1)

missing_freq # affichage dans la console

```

voyageid    shipname    natinimp    placcons      yrcons     placreg       yrreg         
    0.0         4.6         4.4        74.6        82.3        79.3        87.1        

* *shipname*: contient 4,5% de données manquantes. 


```{r eval = FALSE}

# total des données manquantes

sum(missing_n)

```











# Visualisation des données

## Visualisation du tableau de données dans la console

```{r eval = FALSE}

print (voyages) # nombre de lignes limité à 95 lignes
head (voyages) # 6 lignes de tête
tail (voyages) # 6 lignes de fin

# argument supplémentaire n= nb de lignes
head (voyages, n=15) # 15 lignes de tête

```

## Visualisation du tableau de données dans RStudio

Le volet *Environment*, qui liste les objets en mémoire, offre la possibilité d'activer (par un simple clic) l'affichage des tableaux de données dans des onglets dédiés.


![Rstudio] (https://github.com/wilfridcariou/The-Trans-Atlantic-Slave-Trade-Db/blob/master/images/rstudio_dfviz.jpg)



## Visualisation de la série statistique d'une variable
Une série statistique est la suite des observations d'une (ou plusieurs) variable(s), relevés sur les individus d'une population.  
La visualisation d'une série statistique se réalise par la combinaison *nom du tableau*, opérateur *$*, *nom de la variable*.

```{r eval=FALSE}

voyages$shipname

voyages$guns

```











# Manipulations portant sur le tableau de données


## Manipulation des colonnes 


### Sélection de colonnes


#### Sélection en utilisant la syntaxe de R{base}

[lignes,colonnes] 
L'ommission d'un élement permet de sélectionner une ligne ou une colonne entiere
[,colonnes] 
[lignes,]


* Le mode le plus simple d'indexation consiste à indiquerla position dans le *data.frame* des colonnes ? conserver : dans cet exemple, les colonnes 1 et 2
[,]

````{r eval=FALSE}
# La syntaxe suit une notation virgule crochet [,colonne]
eg1_handld_column<- (voyages[,1:2]) 

````

* Un autre mode d'indexation consiste ? s?lectionner des colonnes par la saisie des noms de variable. (fonction *c (combine)*.

````{r eval=FALSE}
# La syntaxe suit une notation crochet
eg1_handld_column <- voyages[,c("voyageid","ptdepimp")] 


````

* S?lection par suppression

```{r eval = FALSE}
eg1_handld_column <- voyages[,-10] # par convention, un indoce pr?c?d? d'un signe moins signifie que l'on supprime l'?lement situ? ? cet indice
eg1_handld_column <- voyages[,-(10:105)] #i par convention, un indoce pr?c?d? d'un signe moins signifie que l'on supprime l'?lement situ? ? cet indice

```


#### S?lection de colonnes en utilisant le package dplyr  {dplyr}

Fonction select


````{r eval=FALSE}

library (dplyr)

eg_handld_column <- voyages %>%
                    select (1:2)

eg_handld_column <- voyages %>%
                    select(1,2)


eg_handld_column <- voyages %>%
                    select(voyageid, shipname)
                  
                  
eg_handld_column <- voyages %>%
                    select(-(2:105))

````


### R?agencement des colonnes du tableau de donn?es

#### R?agencement colonne/colonne

##### fonction *combine* et notation crochet {base}


```{r eval=FALSE}

# Fonction wich : indexation d'un nom de colonne


which(colnames(voyages)=="yearam")

eg3_handld_column<- (voyages[,c(1,54,2:105)]) 

eg3_handld_column<- (voyages[,-55])


```


##### Fonction *select* (package dplyr)



```{r eval=FALSE}
# Ne "doublonne pas la variable" d?plac?e

data_small1<- voyages %>%
  select(voyageid, yearam, shipname, ownera,
         captaina,ptdepimp, majbyimp,
         mjselimp,
         voy1imp, slaximp)
         


eg4_handld_column <- voyages %>%
                select(1,54,2:105)

````


##### Fonction *select* : outils sp?ciaux

Outils simplificateurs (documentation : dplyr sheat sheet)

```{r eval = FALSE}

eg_handld_column<- voyages %>%
                   select(starts_with(owner))

```



#### R?agencement selon un tri alphab?tique des noms de colonnes

```{r eval = FALSE}

alphabet_data <- voyages %>%
                 select (order(colnames(.)))

```

* fonction order {base}
* fonction colnames {base}
* signe point: n'importe quel caract?re?


r?f?rence: stack overflow: Dplyr order columns aphabetically in R














************************************************************************************************************************
##  S?lection des lignes



### S?lection selon une modalit? appartenant ? un caract?re 

Exemple de la modalit? *Nantes*, appartenant au caract?re *ptdepimp* (ports de d?part des exp?ditions de traite).



#### S?lection de lignes, notation crochet et fonction *subset* (R base) 

````{r eval=FALSE}

# Aper?u des modalit?s de la variable ptdepimp
levels (dataR1$ptdepimp) 


# Indexation: la syntaxe suit une notation crochet
eg1_nantes <- voyages[voyages$ptdepimp=="Nantes",]


# Visualisation
utils::View  (eg_1nantes)
summary (eg1_nantes$ptdepimp)
# les valeurs manquantes sont inclues dans l'indexation


# proposition 2: l'utilisation fonction subset exclue par d?faut 
# les valeurs manquantes
nantesR3 <- subset(voyages, ptdepimp=="Nantes")
nantesR3
summary (nantesR3$ptdepimp)
````



####  S?lection de lignes, fonction *filter* (package dplyr)



````{r eval=FALSE}

nantes <- voyages %>% 
          filter (ptdepimp == "Nantes")
````

### S?lection selon une valeur 

````{r eval=FALSE}
library (dplyr)



year1789 <- voyages %>%
            filter(yearam == 1789)

````


https://www.kaggle.com/justmarkham/introducing-kaggle-scripts/introduction-to-dplyr-part-2/notebook 

### S?lection selon une combinaison de valeurs appartenant ? une variable


```{r eval = FALSE}
p_1600_1605 <- voyages %>%
                    filter(yearam >= 1600 & yearam < 1605 )
```




### S?lection selon une combinaison de modalit?s appartenant ? un caract?re



````{r eval=FALSE}

library (dplyr)

# d?tour 

grepl("Bristol|London", voyages$ptdepimp)
# Ou
str_detect (voyages$ptdepimp, "Bristol|London")


# combinaison des fonctions
eg_brest_vannes <- voyages %>% 
                   filter( grepl("Bristol|London", ptdepimp))
# ou 

library (stringr)
eg_london_bristol<- voyages %>% 
                   filter( str_detect(ptdepimp, "Bristol|London"))

          

# ne fonctionne pas
library (stringr)
eg3_brestmorlaix <- voyages %>% 
                   filter( ptdepimp =="Vannes" & ptdepimp =="Morlaix")

# pistes avec les symbole %in% (stackoverflow)

````



## S?lection par n?gation d'une cha?ne de caract?res
Utilisation du signe ! (point d'exclamation) comme op?rateur de n?gation

```{r eval = FALSE}
specific_ports <- voyages %>% 
                   filter(!grepl("unspecified", ptdepimp))

specific_ports <- voyages %>% 
                   filter(!str_detect (ptdepimp, "unspecified"),! is.na= TRUE) # supression des NA
                   
                   
```



## Combinaison de modalit?s / valeurs appartenant ? plusieurs caract?res/ variables


###  Combinaison  port de d?part / navire en particulier

```{r eval=FALSE}

nante_db <- voyages %>%
            filter (ptdepimp == "Nantes", shipname == "Duc de Bretagne")

# ou


nante_db <- voyages %>%
            filter (ptdepimp == "Nantes") %>%
            filter (shipname == "Duc de Bretagne")

```



###  Combinaison  port de d?part / navire en particulier

```{r eval=FALSE}

nantes_1789 <- voyages %>%
            filter (ptdepimp == "Nantes", yearam == 1789)

# ou


nantes_1789 <- voyages %>%
            filter (ptdepimp == "Nantes") %>%
            filter (yearam == 1789)

```


### S?lection d'une modalit? portant sur ue ensemble

### S?lection montaudouin chaine?
```{r eval = FALSE}

library (dplyr)
unique(tst_db$ownera) 

Nantes <- tst_db%>%
            filter (ptdepimp == "Nantes")


armateur <- tst_db %>%
            filter(grepl("Montaudouin", ownera))

armateur
unique(tst_db$ownera) 

```

```{r eval = FALSE}

index armateur <- tst_db %>%
            filter(grepl("Montaudouin", ownera))

armateur
unique(tst_db$ownera) 

```






## Tri 

Dplyr fait appel ? la fonction *arrange*.  L'argument par d?faut est un classement par ordre croissant. Pour un classement par ordre d?croissant, l'utilisastion de l'argument *desc()* est recquise.

```{r eval=FALSE}

# {base}
sort_voyages<-traite1700_1800[order(voyages$"yearam"),] 



# {dplyr}
datachrono <- dataset_tst %>%
                arrange (yearam)


data_small1<- voyages %>%
              select(voyageid, yearam, shipname, ownera,
              captaina,ptdepimp, majbyimp,
              mjselimp,
              voy1imp, slaximp) %>%
              arrange (yearam)


nantesD2 <- voyages %>%
            filter (ptdepimp=="Nantes") %>%
            arrange (yearam)

# Combinaison  port de d?part / chrono / navire en particulier


nantesD3 <- voyages %>% filter (ptdepimp == "Nantes", shipname == "Duc de Bretagne")
                       %>% arrange (yearam)

```



## Recherche de combinaisons uniques: exemple de l'identification des navires


Identification des navires un et un tonnage similaire


YRCONS Year of vessel's construction
PLACCONS Place where vessel constructed
YRREG Year of vessel's registration
PLACREG Place where vessel registered


```{r eval = FALSE}



unique_ships1 <-voyages %>% 
           select (shipname, tonnage, placreg, yrreg) %>%
           distinct(shipname, tonnage) %>%
           filter (!is.na(tonnage == TRUE)) %>%
           arrange(shipname)


unique_ships2<-voyages %>% 
           select (shipname, tonnage, placreg, yrreg, ptdepimp) %>%
           distinct(shipname, placreg, yrreg) %>%
           filter (!is.na(tonnage == TRUE), !is.na(placreg == TRUE), ptdepimp =="Nantes") %>%
           arrange(shipname)




uniques2 <-unique_ships1  %>% 
group_by (shipname) %>% 
summarise( n=n())
uniques2

  



di <- data_small1 %>%
      filter (ptdepimp == "Nantes")
      distinct(shipname)
````


Selection NA NON NA

```{r eval = FALSE}
colnames (tst_db)      
tst_db_complete <- tst_db %>%
                   filter(!is.na(1:10) = TRUE)    
                   
tst_db_complete

# Or a little more general:

library(dplyr) # 0.4
df %>% filter(complete.cases(1:12,27:88))

```



