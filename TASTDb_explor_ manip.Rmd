---
title: "Exploration et manipulation des tableaux de données"
author: "Wilfrid Cariou"
date: "20 décembre 2015"
output: 
  html_document: 
    number_sections: yes
    toc: yes
---





Références:

http://blog.datacamp.com/15-easy-solutions-data-frame-problems-r/  
https://www.datacamp.com/courses/dplyr-data-manipulation-r-tutorial  
http://personal.colby.edu/personal/m/mgimond/RIntro/04_Manipulating_data_tables.html#data-table-description  
http://www.r-bloggers.com/imputing-missing-data-with-r-mice-package/  
https://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html  
https://stat545-ubc.github.io/block010_dplyr-end-single-table.html  


# Composition du tableau de données *voyages*

Un tableau de données ou *data.frame* constitue une structure de données fondamentale de **R**. Il se compose d'une collection d'objets de différents types (*numeric, factor, character*) de longueurs similaires accessibles par leur indice de position (R: A Language and Environment for Statistical Computing - Reference index, p 159).

## Dimensions du tableau

Un tableau de données est un tableau à deux dimensions. La fonction *dim(){base}*  permet d'en connaître le nombre de lignes et de colonnes (Becker, Chambers, Wilks, 1988).

```{r eval = FALSE}

dim (voyages)

```

## Désignation et indice de position des colonnes

* La fonction *colnames(){base}* est utilisée pour obtenir un affichage séquentiel des noms de colonnes. Chaque colonne est caractérisée par un *indice* de position au sein du tableau. l'indice du premier élément de chaque ligne est signalé dans la marge gauche de la console.   
* La fonction *wich(){base}* est une fonction primitive de **R** qui permet d'identifier l'indice de position d'un vecteur (d'une colonne) en fonction de son nom (Desgraupes, 2013, p10).

```{r eval = FALSE}

# Fonction names {base}: Affichage index de la désignation des colonnes du tableau 
colnames (voyages)

# Affichage de la position  d'une colonne en fonction de son nom.
which(colnames(voyages)=="slaximp")

```

## Typage des données

```{r eval = FALSE}

str(voyages)

```
### Les facteurs 

Un  *facteur (factor)* constitue un objet particulier de **R** employé pour stocker les modalités d'un caractère qualitatif. 
Un caractère est dit *qualitatif* lorsque son observation ne peut être traduite par une mesure. Il se décline selon différents états dénombrables appelés *modalités*. Dans **r**, les  *levels* correspondent aux modalités d'un caractère.
L'inspection des modalités d'un caractère qualitatif s'effectue à l'aide de la fonction *levels() ou unique() {base}*. 

````{r eval=FALSE}

levels (voyages$ptdepimp) # ports de départ des expéditions de traite
unique (voyages$ptdepimp) # ports de départ des expéditions de traite

````

### Les vecteurs numériques 

Les *Integer* ou *numeric*  sont des objets utilisés pour stocker des valeurs d'une variable quantitative. 

```{r eval = FALSE}

# Exemple: les dix premières valeurs  de la variable yearam
head (voyages$slaximp) 

```

### Les Valeurs manquantes

#### Désignation

Dans **R**, les valeurs manquantes sont notées *NA* (not available).

#### Remarque

Par défaut, la plupart des fonctions de base (somme, moyenne, minimum, maximum, etc.) n'acceptent pas les variables 
contenant des valeurs manquantes.

#### Identification des valeurs manquantes

Références: http://www.statmethods.net/input/missingdata.html


La fonction *summary* permet entre autre d'indiquer les effectifs des valeurs manquantes pour chaque variable du tableau de données.

````{r eval=FALSE}

summary (voyages)

````

Pour poursuivre,il s'avère utile de pouvoir construire un tableau statistique des effectifs et  des fréquences des valeurs manquantes *variable par variable*.

```{r eval = FALSE}

# fonction colSums

colSums(is.na(voyages)) 

missing<-colSums(is.na(voyages))
missing

# fonction sum

sum (missing)

# options(scipen=x) where x is the number of decimal places you want to display
options("scipen"=9999)
````

F=\frac{effectif}{effectif total}

```{r eval = FALSE}
#Fr?quences des valeurs manquantes
## V1

missing_freq <- missing/200
missing_freq
effectif_total <- nrow(voyages) 
effectif_total

## V2


missing_freq <- missing/effectif_total
missing_freq

```



# Visualisation des données

## visualisation du tableau de donn?es dans la console

```{r eval = FALSE}
print (voyages) # nombre de lignes limit? ? 95 lignes
head (voyages) # 6 lignes de t?te
tail (voyages) # 6 lignes de fin
# argument suppl?mentaire n= nb de lignes
```

## Visualisation du tableau de donn?es dans Rstudio

Le volet Environment de *Rtudio* permet d'acc?der aux objets contenus dans la m?moire de R et afficher les *data.frames* dans un onglet. (copi?-coll? possible vers le tableur)


## Visualisation de la s?rie statistique d'une variable
Une s?rie statistique est la suite des observations d'une (ou plusieurs) variable(s), relev?es sur les individus d'une
population. Il se r?alise par la combinaison *nom du tableau*, op?rateur
*$*, *nom de la variable*.

```{r eval=FALSE}
voyages$slaximp
voyages$ptdepimp

```



## autres outils de visualisation

library (Kmisc)

htmlTable
Generate an HTML Table

htmlTable (voyages)



library (googleVis)
datagtable <- gvisTable(data_small1, 
                        options=list(page='enable',
                        height='automatic',
                        width='automatic'))
plot (datagtable )

### GoogleVis (ne fonctionne pas avec des tableaux larges)

porbl?me du codage de cart?re unicode system


library (googleVis)
datagtable <- gvisTable(voyages, 
                        height='automatic')
plot (datagtable )



# Manipulation du tableau de donn?es


## Manipulation des colonnes 


### S?lection de colonnes


#### S?lection en utilisant les outils de base {base}

[lignes,colonnes] 
L'ommission d'un ?lement permet de s?lectionner une ligne ou une colonne entiere
[,colonnes] 
[lignes,]


* Le mode le plus simple d'indexation consiste ? indiquerla position dans le *data.frame* des colonnes ? conserver : dans cet exemple, les colonnes 1 et 2
[,]

````{r eval=FALSE}
# La syntaxe suit une notation virgule crochet [,colonne]
eg1_handld_column<- (voyages[,1:2]) 

````

* Un autre mode d'indexation consiste ? s?lectionner des colonnes par la saisie des noms de variable. (fonction *c (combine)*.

````{r eval=FALSE}
# La syntaxe suit une notation crochet
eg1_handld_column <- voyages[,c("voyageid","ptdepimp")] 


````

* S?lection par suppression

```{r eval = FALSE}
eg1_handld_column <- voyages[,-10] # par convention, un indoce pr?c?d? d'un signe moins signifie que l'on supprime l'?lement situ? ? cet indice
eg1_handld_column <- voyages[,-(10:105)] #i par convention, un indoce pr?c?d? d'un signe moins signifie que l'on supprime l'?lement situ? ? cet indice

```


#### S?lection de colonnes en utilisant le package dplyr  {dplyr}

Fonction select


````{r eval=FALSE}

library (dplyr)

eg_handld_column <- voyages %>%
                    select (1:2)

eg_handld_column <- voyages %>%
                    select(1,2)


eg_handld_column <- voyages %>%
                    select(voyageid, shipname)
                  
                  
eg_handld_column <- voyages %>%
                    select(-(2:105))

````


### R?agencement des colonnes du tableau de donn?es

#### R?agencement colonne/colonne

##### fonction *combine* et notation crochet {base}


```{r eval=FALSE}

# Fonction wich : indexation d'un nom de colonne


which(colnames(voyages)=="yearam")

eg3_handld_column<- (voyages[,c(1,54,2:105)]) 

eg3_handld_column<- (voyages[,-55])


```


##### Fonction *select* (package dplyr)



```{r eval=FALSE}
# Ne "doublonne pas la variable" d?plac?e

data_small1<- voyages %>%
  select(voyageid, yearam, shipname, ownera,
         captaina,ptdepimp, majbyimp,
         mjselimp,
         voy1imp, slaximp)
         


eg4_handld_column <- voyages %>%
                select(1,54,2:105)

````


##### Fonction *select* : outils sp?ciaux

Outils simplificateurs (documentation : dplyr sheat sheet)

```{r eval = FALSE}

eg_handld_column<- voyages %>%
                   select(starts_with(owner))

```



#### R?agencement selon un tri alphab?tique des noms de colonnes

```{r eval = FALSE}

alphabet_data <- voyages %>%
                 select (order(colnames(.)))

```

* fonction order {base}
* fonction colnames {base}
* signe point: n'importe quel caract?re?


r?f?rence: stack overflow: Dplyr order columns aphabetically in R














************************************************************************************************************************
##  S?lection des lignes



### S?lection selon une modalit? appartenant ? un caract?re 

Exemple de la modalit? *Nantes*, appartenant au caract?re *ptdepimp* (ports de d?part des exp?ditions de traite).



#### S?lection de lignes, notation crochet et fonction *subset* (R base) 

````{r eval=FALSE}

# Aper?u des modalit?s de la variable ptdepimp
levels (dataR1$ptdepimp) 


# Indexation: la syntaxe suit une notation crochet
eg1_nantes <- voyages[voyages$ptdepimp=="Nantes",]


# Visualisation
utils::View  (eg_1nantes)
summary (eg1_nantes$ptdepimp)
# les valeurs manquantes sont inclues dans l'indexation


# proposition 2: l'utilisation fonction subset exclue par d?faut 
# les valeurs manquantes
nantesR3 <- subset(voyages, ptdepimp=="Nantes")
nantesR3
summary (nantesR3$ptdepimp)
````



####  S?lection de lignes, fonction *filter* (package dplyr)



````{r eval=FALSE}

nantes <- voyages %>% 
          filter (ptdepimp == "Nantes")
````

### S?lection selon une valeur 

````{r eval=FALSE}
library (dplyr)



year1789 <- voyages %>%
            filter(yearam == 1789)

````


https://www.kaggle.com/justmarkham/introducing-kaggle-scripts/introduction-to-dplyr-part-2/notebook 

### S?lection selon une combinaison de valeurs appartenant ? une variable


```{r eval = FALSE}
p_1600_1605 <- voyages %>%
                    filter(yearam >= 1600 & yearam < 1605 )
```




### S?lection selon une combinaison de modalit?s appartenant ? un caract?re



````{r eval=FALSE}

library (dplyr)

# d?tour 

grepl("Bristol|London", voyages$ptdepimp)
# Ou
str_detect (voyages$ptdepimp, "Bristol|London")


# combinaison des fonctions
eg_brest_vannes <- voyages %>% 
                   filter( grepl("Bristol|London", ptdepimp))
# ou 

library (stringr)
eg_london_bristol<- voyages %>% 
                   filter( str_detect(ptdepimp, "Bristol|London"))

          

# ne fonctionne pas
library (stringr)
eg3_brestmorlaix <- voyages %>% 
                   filter( ptdepimp =="Vannes" & ptdepimp =="Morlaix")

# pistes avec les symbole %in% (stackoverflow)

````



## S?lection par n?gation d'une cha?ne de caract?res
Utilisation du signe ! (point d'exclamation) comme op?rateur de n?gation

```{r eval = FALSE}
specific_ports <- voyages %>% 
                   filter(!grepl("unspecified", ptdepimp))

specific_ports <- voyages %>% 
                   filter(!str_detect (ptdepimp, "unspecified"),! is.na= TRUE) # supression des NA
                   
                   
```



## Combinaison de modalit?s / valeurs appartenant ? plusieurs caract?res/ variables


###  Combinaison  port de d?part / navire en particulier

```{r eval=FALSE}

nante_db <- voyages %>%
            filter (ptdepimp == "Nantes", shipname == "Duc de Bretagne")

# ou


nante_db <- voyages %>%
            filter (ptdepimp == "Nantes") %>%
            filter (shipname == "Duc de Bretagne")

```



###  Combinaison  port de d?part / navire en particulier

```{r eval=FALSE}

nantes_1789 <- voyages %>%
            filter (ptdepimp == "Nantes", yearam == 1789)

# ou


nantes_1789 <- voyages %>%
            filter (ptdepimp == "Nantes") %>%
            filter (yearam == 1789)

```


### S?lection d'une modalit? portant sur ue ensemble

### S?lection montaudouin chaine?
```{r eval = FALSE}

library (dplyr)
unique(tst_db$ownera) 

Nantes <- tst_db%>%
            filter (ptdepimp == "Nantes")


armateur <- tst_db %>%
            filter(grepl("Montaudouin", ownera))

armateur
unique(tst_db$ownera) 

```

```{r eval = FALSE}

index armateur <- tst_db %>%
            filter(grepl("Montaudouin", ownera))

armateur
unique(tst_db$ownera) 

```






## Tri 

Dplyr fait appel ? la fonction *arrange*.  L'argument par d?faut est un classement par ordre croissant. Pour un classement par ordre d?croissant, l'utilisastion de l'argument *desc()* est recquise.

```{r eval=FALSE}

# {base}
sort_voyages<-traite1700_1800[order(voyages$"yearam"),] 



# {dplyr}
datachrono <- dataset_tst %>%
                arrange (yearam)


data_small1<- voyages %>%
              select(voyageid, yearam, shipname, ownera,
              captaina,ptdepimp, majbyimp,
              mjselimp,
              voy1imp, slaximp) %>%
              arrange (yearam)


nantesD2 <- voyages %>%
            filter (ptdepimp=="Nantes") %>%
            arrange (yearam)

# Combinaison  port de d?part / chrono / navire en particulier


nantesD3 <- voyages %>% filter (ptdepimp == "Nantes", shipname == "Duc de Bretagne")
                       %>% arrange (yearam)

```



## Recherche de combinaisons uniques: exemple de l'identification des navires


Identification des navires un et un tonnage similaire


YRCONS Year of vessel's construction
PLACCONS Place where vessel constructed
YRREG Year of vessel's registration
PLACREG Place where vessel registered


```{r eval = FALSE}



unique_ships1 <-voyages %>% 
           select (shipname, tonnage, placreg, yrreg) %>%
           distinct(shipname, tonnage) %>%
           filter (!is.na(tonnage == TRUE)) %>%
           arrange(shipname)


unique_ships2<-voyages %>% 
           select (shipname, tonnage, placreg, yrreg, ptdepimp) %>%
           distinct(shipname, placreg, yrreg) %>%
           filter (!is.na(tonnage == TRUE), !is.na(placreg == TRUE), ptdepimp =="Nantes") %>%
           arrange(shipname)




uniques2 <-unique_ships1  %>% 
group_by (shipname) %>% 
summarise( n=n())
uniques2

  



di <- data_small1 %>%
      filter (ptdepimp == "Nantes")
      distinct(shipname)
````


Selection NA NON NA

```{r eval = FALSE}
colnames (tst_db)      
tst_db_complete <- tst_db %>%
                   filter(!is.na(1:10) = TRUE)    
                   
tst_db_complete

# Or a little more general:

library(dplyr) # 0.4
df %>% filter(complete.cases(1:12,27:88))

```



